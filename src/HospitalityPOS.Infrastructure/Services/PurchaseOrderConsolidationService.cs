using Microsoft.EntityFrameworkCore;
using HospitalityPOS.Core.Entities;
using HospitalityPOS.Core.Enums;
using HospitalityPOS.Core.Interfaces;
using HospitalityPOS.Infrastructure.Data;

namespace HospitalityPOS.Infrastructure.Services;

/// <summary>
/// Service for consolidating purchase orders by supplier.
/// </summary>
public class PurchaseOrderConsolidationService : IPurchaseOrderConsolidationService
{
    private readonly POSDbContext _context;
    private readonly IPurchaseOrderSettingsService _settingsService;
    private readonly INotificationService _notificationService;

    public PurchaseOrderConsolidationService(
        POSDbContext context,
        IPurchaseOrderSettingsService settingsService,
        INotificationService notificationService)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _notificationService = notificationService ?? throw new ArgumentNullException(nameof(notificationService));
    }

    /// <inheritdoc />
    public async Task<ConsolidationResult> CreateConsolidatedPurchaseOrdersAsync(
        int storeId,
        IEnumerable<int>? suggestionIds = null,
        bool sendImmediately = false,
        CancellationToken cancellationToken = default)
    {
        var result = new ConsolidationResult { Success = true };
        var settings = await _settingsService.GetEffectiveSettingsAsync(storeId, cancellationToken).ConfigureAwait(false);

        using var transaction = await _context.Database.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);

        try
        {
            // Get approved suggestions
            var query = _context.ReorderSuggestions
                .Include(s => s.Product)
                .Include(s => s.Supplier)
                .Where(s => s.StoreId == storeId && s.Status == "Approved" && !s.IsDeleted);

            if (suggestionIds != null && suggestionIds.Any())
            {
                query = query.Where(s => suggestionIds.Contains(s.Id));
            }

            var suggestions = await query.ToListAsync(cancellationToken).ConfigureAwait(false);

            if (!suggestions.Any())
            {
                result.Warnings.Add("No approved suggestions found to process.");
                return result;
            }

            result.SuggestionsProcessed = suggestions.Count;

            // Group by supplier
            var supplierGroups = suggestions
                .Where(s => s.SupplierId.HasValue)
                .GroupBy(s => s.SupplierId!.Value)
                .ToList();

            // Track suggestions without supplier
            var noSupplierSuggestions = suggestions.Where(s => !s.SupplierId.HasValue).ToList();
            if (noSupplierSuggestions.Any())
            {
                result.SuggestionsSkipped += noSupplierSuggestions.Count;
                result.Warnings.Add($"Skipped {noSupplierSuggestions.Count} suggestions without supplier.");
            }

            foreach (var group in supplierGroups)
            {
                var supplierId = group.Key;
                var supplierSuggestions = group.ToList();

                // Split into chunks if exceeds max items
                var chunks = ChunkSuggestions(supplierSuggestions, settings.MaxItemsPerPO);

                foreach (var chunk in chunks)
                {
                    var totalValue = chunk.Sum(s => s.EstimatedCost);

                    // Check minimum amount
                    if (totalValue < settings.MinimumPOAmount)
                    {
                        result.SuggestionsSkipped += chunk.Count;
                        result.Warnings.Add($"Skipped {chunk.Count} items for supplier {supplierId} - below minimum PO amount ({totalValue:C} < {settings.MinimumPOAmount:C})");
                        continue;
                    }

                    // Create PO
                    var poNumber = await GeneratePONumberAsync(cancellationToken).ConfigureAwait(false);
                    var supplier = await _context.Suppliers.FindAsync(new object[] { supplierId }, cancellationToken).ConfigureAwait(false);

                    var purchaseOrder = new PurchaseOrder
                    {
                        StoreId = storeId,
                        SupplierId = supplierId,
                        PONumber = poNumber,
                        OrderDate = DateTime.UtcNow,
                        ExpectedDate = DateTime.UtcNow.AddDays(supplier?.PaymentTermDays ?? settings.DefaultLeadTimeDays),
                        Status = sendImmediately ? PurchaseOrderStatus.Sent : PurchaseOrderStatus.Draft,
                        IsAutoGenerated = true,
                        GenerationReason = "Auto-generated from reorder suggestions",
                        Priority = DeterminePriority(chunk),
                        CreatedAt = DateTime.UtcNow
                    };

                    _context.PurchaseOrders.Add(purchaseOrder);
                    await _context.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

                    // Add items
                    decimal subTotal = 0;
                    foreach (var suggestion in chunk)
                    {
                        var item = new PurchaseOrderItem
                        {
                            PurchaseOrderId = purchaseOrder.Id,
                            ProductId = suggestion.ProductId,
                            OrderedQuantity = suggestion.SuggestedQuantity,
                            UnitCost = suggestion.Product?.Cost ?? 0,
                            TotalCost = suggestion.EstimatedCost,
                            CreatedAt = DateTime.UtcNow
                        };
                        _context.PurchaseOrderItems.Add(item);
                        subTotal += item.TotalCost;

                        // Update suggestion status
                        suggestion.Status = "Converted";
                        suggestion.PurchaseOrderId = purchaseOrder.Id;
                        suggestion.UpdatedAt = DateTime.UtcNow;
                    }

                    // Update PO totals
                    purchaseOrder.SubTotal = subTotal;
                    purchaseOrder.TaxAmount = subTotal * 0.16m; // 16% VAT
                    purchaseOrder.TotalAmount = purchaseOrder.SubTotal + purchaseOrder.TaxAmount;

                    result.PurchaseOrderIds.Add(purchaseOrder.Id);
                    result.PurchaseOrdersCreated++;
                    result.TotalOrderValue += purchaseOrder.TotalAmount;

                    // Send notification
                    if (sendImmediately)
                    {
                        await _notificationService.NotifyPOGeneratedAsync(
                            purchaseOrder.Id,
                            purchaseOrder.PONumber,
                            purchaseOrder.TotalAmount,
                            cancellationToken).ConfigureAwait(false);
                    }
                    else
                    {
                        await _notificationService.NotifyPOPendingApprovalAsync(
                            purchaseOrder.Id,
                            purchaseOrder.PONumber,
                            purchaseOrder.TotalAmount,
                            cancellationToken).ConfigureAwait(false);
                    }
                }
            }

            await _context.SaveChangesAsync(cancellationToken).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            result.Success = false;
            result.ErrorMessage = ex.Message;
        }

        return result;
    }

    /// <inheritdoc />
    public async Task<IEnumerable<SupplierSuggestionGroup>> GroupSuggestionsBySupplierAsync(
        int storeId,
        IEnumerable<int>? suggestionIds = null,
        CancellationToken cancellationToken = default)
    {
        var settings = await _settingsService.GetEffectiveSettingsAsync(storeId, cancellationToken).ConfigureAwait(false);

        var query = _context.ReorderSuggestions
            .Include(s => s.Product)
            .Include(s => s.Supplier)
            .Where(s => s.StoreId == storeId && s.Status == "Approved" && !s.IsDeleted && s.SupplierId.HasValue);

        if (suggestionIds != null && suggestionIds.Any())
        {
            query = query.Where(s => suggestionIds.Contains(s.Id));
        }

        var suggestions = await query.ToListAsync(cancellationToken).ConfigureAwait(false);

        var groups = suggestions
            .GroupBy(s => s.SupplierId!.Value)
            .Select(g => new SupplierSuggestionGroup
            {
                SupplierId = g.Key,
                SupplierName = g.First().Supplier?.Name ?? "Unknown",
                Suggestions = g.ToList(),
                TotalEstimatedCost = g.Sum(s => s.EstimatedCost),
                ItemCount = g.Count(),
                ProjectedPOCount = (int)Math.Ceiling((double)g.Count() / settings.MaxItemsPerPO)
            })
            .OrderByDescending(g => g.TotalEstimatedCost)
            .ToList();

        return groups;
    }

    /// <inheritdoc />
    public async Task<PurchaseOrder> MergePurchaseOrdersAsync(
        IEnumerable<int> purchaseOrderIds,
        int userId,
        CancellationToken cancellationToken = default)
    {
        var poIds = purchaseOrderIds.ToList();
        if (poIds.Count < 2)
        {
            throw new ArgumentException("At least 2 purchase orders are required for merging.");
        }

        var purchaseOrders = await _context.PurchaseOrders
            .Include(po => po.PurchaseOrderItems)
                .ThenInclude(poi => poi.Product)
            .Include(po => po.Supplier)
            .Where(po => poIds.Contains(po.Id) && !po.IsDeleted)
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);

        if (purchaseOrders.Count != poIds.Count)
        {
            throw new InvalidOperationException("One or more purchase orders not found.");
        }

        // Validate all POs are for the same supplier and are draft
        var supplierIds = purchaseOrders.Select(po => po.SupplierId).Distinct().ToList();
        if (supplierIds.Count > 1)
        {
            throw new InvalidOperationException("Cannot merge purchase orders from different suppliers.");
        }

        if (purchaseOrders.Any(po => po.Status != PurchaseOrderStatus.Draft))
        {
            throw new InvalidOperationException("Can only merge draft purchase orders.");
        }

        using var transaction = await _context.Database.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);

        try
        {
            var supplierId = supplierIds.First();
            var supplier = purchaseOrders.First().Supplier;

            // Create merged PO
            var mergedPO = new PurchaseOrder
            {
                StoreId = purchaseOrders.First().StoreId,
                SupplierId = supplierId,
                PONumber = await GeneratePONumberAsync(cancellationToken).ConfigureAwait(false),
                OrderDate = DateTime.UtcNow,
                ExpectedDate = purchaseOrders.Max(po => po.ExpectedDate),
                Status = PurchaseOrderStatus.Draft,
                IsAutoGenerated = true,
                GenerationReason = $"Merged from POs: {string.Join(", ", purchaseOrders.Select(po => po.PONumber))}",
                CreatedByUserId = userId,
                CreatedAt = DateTime.UtcNow
            };

            _context.PurchaseOrders.Add(mergedPO);
            await _context.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

            // Merge items (combine quantities for same products)
            var allItems = purchaseOrders.SelectMany(po => po.PurchaseOrderItems).ToList();
            var groupedItems = allItems.GroupBy(i => i.ProductId);

            decimal subTotal = 0;
            foreach (var group in groupedItems)
            {
                var totalQty = group.Sum(i => i.OrderedQuantity);
                var avgCost = group.Average(i => i.UnitCost);
                var totalCost = totalQty * avgCost;

                var mergedItem = new PurchaseOrderItem
                {
                    PurchaseOrderId = mergedPO.Id,
                    ProductId = group.Key,
                    OrderedQuantity = totalQty,
                    UnitCost = avgCost,
                    TotalCost = totalCost,
                    CreatedAt = DateTime.UtcNow
                };
                _context.PurchaseOrderItems.Add(mergedItem);
                subTotal += totalCost;
            }

            mergedPO.SubTotal = subTotal;
            mergedPO.TaxAmount = subTotal * 0.16m;
            mergedPO.TotalAmount = mergedPO.SubTotal + mergedPO.TaxAmount;

            // Delete original POs
            foreach (var po in purchaseOrders)
            {
                po.IsDeleted = true;
                po.DeletedAt = DateTime.UtcNow;
                po.DeletedByUserId = userId;
                po.DeletionReason = $"Merged into {mergedPO.PONumber}";
            }

            await _context.SaveChangesAsync(cancellationToken).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return mergedPO;
        }
        catch
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc />
    public async Task<int> GetProjectedPOCountAsync(int storeId, CancellationToken cancellationToken = default)
    {
        var settings = await _settingsService.GetEffectiveSettingsAsync(storeId, cancellationToken).ConfigureAwait(false);

        var approvedCount = await _context.ReorderSuggestions
            .Where(s => s.StoreId == storeId && s.Status == "Approved" && !s.IsDeleted && s.SupplierId.HasValue)
            .GroupBy(s => s.SupplierId)
            .Select(g => new { SupplierId = g.Key, Count = g.Count() })
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);

        return approvedCount.Sum(g => (int)Math.Ceiling((double)g.Count / settings.MaxItemsPerPO));
    }

    /// <inheritdoc />
    public async Task<(bool IsValid, List<string> Errors)> ValidateConsolidationAsync(
        int storeId,
        IEnumerable<int> suggestionIds,
        CancellationToken cancellationToken = default)
    {
        var errors = new List<string>();

        var suggestions = await _context.ReorderSuggestions
            .Include(s => s.Supplier)
            .Where(s => suggestionIds.Contains(s.Id) && !s.IsDeleted)
            .ToListAsync(cancellationToken)
            .ConfigureAwait(false);

        if (!suggestions.Any())
        {
            errors.Add("No valid suggestions found.");
            return (false, errors);
        }

        var notApproved = suggestions.Where(s => s.Status != "Approved").ToList();
        if (notApproved.Any())
        {
            errors.Add($"{notApproved.Count} suggestions are not approved.");
        }

        var noSupplier = suggestions.Where(s => !s.SupplierId.HasValue).ToList();
        if (noSupplier.Any())
        {
            errors.Add($"{noSupplier.Count} suggestions have no supplier assigned.");
        }

        var wrongStore = suggestions.Where(s => s.StoreId != storeId).ToList();
        if (wrongStore.Any())
        {
            errors.Add($"{wrongStore.Count} suggestions are from a different store.");
        }

        return (!errors.Any(), errors);
    }

    private static List<List<ReorderSuggestion>> ChunkSuggestions(List<ReorderSuggestion> suggestions, int chunkSize)
    {
        var chunks = new List<List<ReorderSuggestion>>();

        for (int i = 0; i < suggestions.Count; i += chunkSize)
        {
            chunks.Add(suggestions.Skip(i).Take(chunkSize).ToList());
        }

        return chunks;
    }

    private async Task<string> GeneratePONumberAsync(CancellationToken cancellationToken)
    {
        var today = DateTime.UtcNow;
        var datePrefix = today.ToString("yyyyMMdd");

        var lastPO = await _context.PurchaseOrders
            .Where(po => po.PONumber.StartsWith($"PO-{datePrefix}"))
            .OrderByDescending(po => po.PONumber)
            .FirstOrDefaultAsync(cancellationToken)
            .ConfigureAwait(false);

        int sequence = 1;
        if (lastPO != null)
        {
            var lastSequence = lastPO.PONumber.Split('-').LastOrDefault();
            if (int.TryParse(lastSequence, out var parsed))
            {
                sequence = parsed + 1;
            }
        }

        return $"PO-{datePrefix}-{sequence:D4}";
    }

    private static string DeterminePriority(List<ReorderSuggestion> suggestions)
    {
        if (suggestions.Any(s => s.Priority == "Critical"))
            return "Critical";
        if (suggestions.Any(s => s.Priority == "High"))
            return "High";
        if (suggestions.Any(s => s.Priority == "Medium"))
            return "Medium";
        return "Low";
    }
}
